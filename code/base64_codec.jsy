export class U8Base64Encoder extends TransformStream ::
  constructor(urlsafe, ...args) ::
    super(_u8base64_encode_xform(urlsafe), ...args)

export class U8Base64Decoder extends TransformStream ::
  constructor(urlsafe, ...args) ::
    super(_u8base64_decode_xform(urlsafe), ...args)


export function _u8base64_encode_xform(urlsafe) ::
  const [encode,] = _init_b64lut(urlsafe)

  let m = 0,c = 0
  return @{}
    transform(chunk, controller) ::
      if 1 !== chunk.BYTES_PER_ELEMENT ::
        return controller.error(`Invalid U8 array: ${typeof chunk}`)

      let len = 0 | @ (4*chunk.length + 2)/3
      let u8, v, i=0, u8b64_out = new Uint8Array(len)

      for (u8 of chunk) ::
        if 0 === m ::
          v = (u8 & 0xfc) >> 2
          c = u8 & 0x3
          u8b64_out[i++] = encode[v]
          m = 1

        else if 1 === m ::
          v = (c << 4) | ((u8 & 0xf0) >> 4)
          c = u8 & 0x0f
          u8b64_out[i++] = encode[v]
          m = 2

        else ::
          v = (c << 2) | ((u8 & 0xc0) >> 6)
          u8b64_out[i++] = encode[v]

          v = u8 & 0x3f
          u8b64_out[i++] = encode[v]
          m = c = 0

      controller.enqueue(u8b64_out.slice(0,i))

    flush(controller) ::
      if 0 !== m ::
        let e = encode[1===m ? c << 4 : c << 2]
        let tail = urlsafe ? [e]
          : 2===m ? [e, 61]
          : [e, 61, 61]
          
        controller.enqueue(Uint8Array.from(tail))


export function _u8base64_decode_xform(urlsafe) ::
  let [,decode] = _init_b64lut(urlsafe)
  let m = 0, c = 0

  return @{}
    transform(chunk, controller) ::
      if 'string' === typeof chunk ::
        chunk = new TextEncoder().encode(chunk)
      if 1 !== chunk.BYTES_PER_ELEMENT ::
        return controller.error(`Invalid U8 array: ${typeof chunk}`)

      let u8b64, b6, i=0, u8_out = new Uint8Array(chunk.byteLength)
      for (u8b64 of chunk) ::
        b6 = decode[u8b64]
        if undefined === b6 :: return controller.error(`Invalid base64: ${u8}`)
        if null === b6 :: continue // valid whitespace

        if (0 === m) ::
          c = b6 << 2
          m = 1 // only have 6 bits, no complete byte to emit

        else if (1 === m) ::
          u8_out[i++] = c | (b6 >> 4)
          c = (b6 & 0xf) << 4
          m = 2

        else if (2 === m) ::
          u8_out[i++] = c | (b6 >> 2)
          c = (b6 & 0x3) << 6
          m = 3

        else ::
          u8_out[i++] = c | b6
          m = c = 0

      controller.enqueue(u8_out.slice(0,i))


var _x_b64lut
function _init_b64lut(urlsafe) ::
  if undefined === _x_b64lut ::
    let encode=[], decode=[]
    for let se of ['AZ','az','09'] ::
      for let i=se.charCodeAt(0), e=se.charCodeAt(1); i<=e; i++ ::
        decode[i] = encode.length
        encode.push(i)

    decode[9] = decode[10] = decode[13] = decode[32] = decode[61] = null // whitespace and equal: '\t\n\r ='

    decode[encode[62] = 43] = 62 // value 62 is base64 '+' (char code 43)
    decode[encode[63] = 47] = 63 // value 63 is base64 '/' (char code 47)

    let encode_url=encode.slice(), decode_url=decode.slice()

    decode_url[encode_url[62] = 45] = 62 // value 62 is base64url '-' (char code 45)
    decode_url[encode_url[63] = 95] = 63 // value 63 is base64url '_' (char code 95)

    _x_b64lut = [[encode, decode], [encode_url, decode_url]]

  return _x_b64lut[urlsafe ? 1 : 0]

